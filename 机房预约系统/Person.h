#pragma once
#include<iostream>
//using namespace std; //这行在.h头文件不要写,可能会出错
//通常情况下，#pragma once应该放在头文件的最开始，#include指令应该放在#pragma once之后。

//创建一个Person的父类,让三个子类对象继承这个类
class Person
{
public: 

	//展示界面的纯虚函数,子类重写此函数并调用后,方可展示各自的菜单界面
	//父类变为抽象类,无法实例化对象,子类必须重写纯虚函数
	virtual void operMenu() = 0;

public:
	//三个子类的共性
	int id;
	std::string name; //要是不写using namespace std的话,需要写成std::string
	std::string password;
};
	
/*在 C++ 中，string 类型是定义在 <string> 头文件中的标准库类型。
在您的代码中，虽然没有显式地使用 using namespace std，但是您包含了 <iostream> 头文件，这个头文件中包含了 <string> 头文件。
因此，虽然您没有写 using namespace std，但是您的代码可以编译运行，
因为程序中已经包含了 <string> 头文件，并且该头文件中定义了 std::string 类型。
不过，为了避免潜在的命名冲突，建议您在使用 string 类型时显式地指定命名空间，例如 std::string，以确保程序的可读性和可维护性。*/

/*是的，即使代码没有报错，最好也要写成 std::string，因为这样可以提高代码的可读性和可维护性，尤其是当代码量较大时。
此外，明确指定命名空间也可以避免潜在的命名冲突问题。因此，最好养成在代码中显式指定命名空间的习惯。*/

/*是的，通常建议将 using namespace std 放在 .cpp 源文件中而不是头文件中。
将 using namespace std 放在头文件中可能会导致一些潜在的问题，例如：
原因:
1.可能会与其他头文件中定义的函数或变量发生命名冲突。
2.可能会让代码的可移植性降低，因为不同的编译器可能会将相同的库定义在不同的命名空间中。
3.可能会使代码难以阅读和理解，因为您无法确定其他开发人员是否使用了相同的命名空间。
因此，建议将 using namespace std 放在 .cpp 源文件中，并在需要使用标准库中的类型或函数时显式指定命名空间，
例如 std::string、std::cout 等。这样可以避免上述问题，并提高代码的可读性和可维护性。*/

/*除了 std::string 之外，如果没有使用 using namespace std，则需要在使用标准库中的其他标识符或函数时显式指定其命名空间。例如：
1.标准输入输出流 std::cout 和 std::cin。
2.标准库算法 std::sort、std::find 等。
3.标准库容器 std::vector、std::map 等。
4.标准库数学函数 std::sqrt、std::abs 等。
在头文件中，如果使用了这些标识符或函数，需要使用 std:: 前缀显式指定其命名空间，以避免与其他命名空间中的同名标识符发生冲突。*/

/*我创建了三个文件: 1."a.h"的头文件 2."b.h"的头文件 3."b.cpp"的源文件
问题:当我在"b.cpp"的源文件中要用到"a.h"的头文件中的内容,那么"#include"a.h""是在"b.h"的头文件中写,还是在"b.cpp"的源文件写

通常情况下，你应该在"b.cpp"的源文件中包含"a.h"头文件，因为只有在实现文件中需要使用"a.h"头文件的内容。
如果你在"b.h"中包含"a.h"，并且在另一个源文件中包含了"b.h"，那么编译器会将"a.h"头文件包含两次，这可能会导致编译错误。
另外，包含头文件的最佳位置是实现文件的顶部，因为这样可以确保它们在编译时只包含一次。*/

/*你说的:"另外，包含头文件的最佳位置是实现文件的顶部，因为这样可以确保它们在编译时只包含一次。" 
如果我要在实现文件中包含多个头文件怎么办*/

/*如果你需要在一个实现文件中包含多个头文件，可以按照需要在文件的顶部按顺序依次包含它们。
这通常是最常见的情况，因为不同的头文件可能包含不同的类或函数声明，你需要在实现文件中使用它们。
在这种情况下，包含头文件的顺序是很重要的。
通常，你应该首先包含当前实现文件需要的头文件，然后是其它的系统或库头文件。
这样可以确保它们按正确的顺序包含，从而避免一些潜在的编译错误。

这里的顶部指的是代码实现的上方,
不要扣字眼,认为是第一行*/